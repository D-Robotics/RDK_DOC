"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[866],{29094:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>_,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var i=e(74848),r=e(28453);const s={sidebar_position:7},a="SPI\u8c03\u8bd5\u6307\u5357",d={id:"Advanced_development/linux_development/driver_development_x5/driver_spi_dev",title:"SPI\u8c03\u8bd5\u6307\u5357",description:"SPI\u786c\u4ef6\u652f\u6301",source:"@site/docs/07_Advanced_development/02_linux_development/driver_development_x5/driver_spi_dev.md",sourceDirName:"07_Advanced_development/02_linux_development/driver_development_x5",slug:"/Advanced_development/linux_development/driver_development_x5/driver_spi_dev",permalink:"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_spi_dev",draft:!1,unlisted:!1,editUrl:"https://github.com/D-Robotics/rdk_doc/blob/main/docs/07_Advanced_development/02_linux_development/driver_development_x5/driver_spi_dev.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"IO-DOMAIN\u8c03\u8bd5\u6307\u5357",permalink:"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_io_domain_dev"},next:{title:"Thermal \u7cfb\u7edf",permalink:"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_thermal_dev"}},_={},c=[{value:"SPI\u786c\u4ef6\u652f\u6301",id:"spi\u786c\u4ef6\u652f\u6301",level:2},{value:"Linux SPI\u9a71\u52a8\u6846\u67b6\u4ecb\u7ecd",id:"linux-spi\u9a71\u52a8\u6846\u67b6\u4ecb\u7ecd",level:2},{value:"\u4ee3\u7801\u8def\u5f84",id:"\u4ee3\u7801\u8def\u5f84",level:3},{value:"\u63a7\u5236\u5668\u786c\u4ef6\u8bf4\u660e",id:"\u63a7\u5236\u5668\u786c\u4ef6\u8bf4\u660e",level:3},{value:"DTS\u914d\u7f6e\u8bf4\u660e",id:"dts\u914d\u7f6e\u8bf4\u660e",level:3},{value:"DTS\u914d\u7f6eSPI\u4f7f\u7528DMA",id:"dts\u914d\u7f6espi\u4f7f\u7528dma",level:3},{value:"SPI\u529f\u80fd\u9a8c\u8bc1",id:"spi\u529f\u80fd\u9a8c\u8bc1",level:2},{value:"\u6d4b\u8bd5\u73af\u5883\u51c6\u5907",id:"\u6d4b\u8bd5\u73af\u5883\u51c6\u5907",level:3},{value:"SPI \u5185\u90e8\u56de\u73af\u6d4b\u8bd5",id:"spi-\u5185\u90e8\u56de\u73af\u6d4b\u8bd5",level:3},{value:"\u9644\u5f55",id:"\u9644\u5f55",level:2}];function x(t){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"spi\u8c03\u8bd5\u6307\u5357",children:"SPI\u8c03\u8bd5\u6307\u5357"}),"\n",(0,i.jsx)(n.h2,{id:"spi\u786c\u4ef6\u652f\u6301",children:"SPI\u786c\u4ef6\u652f\u6301"}),"\n",(0,i.jsx)(n.p,{children:"X5\u5171\u652f\u63017\u8defSPI\u63a7\u5236\u5668\uff0c\u5176\u4e2d6\u8def(spi0-spi5)\u4f4d\u4e8eLSIO\u5b50\u7cfb\u7edf\uff0c1\u8def(spi6)\u4f4d\u4e8eDSP\u5b50\u7cfb\u7edf\u3002 \u6240\u6709SPI\u63a7\u5236\u5668\u5747\u652f\u6301\u4e3b/\u4ece\u6a21\u5f0f\u3002"}),"\n",(0,i.jsx)(n.h2,{id:"linux-spi\u9a71\u52a8\u6846\u67b6\u4ecb\u7ecd",children:"Linux SPI\u9a71\u52a8\u6846\u67b6\u4ecb\u7ecd"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"spi driver\u5c42\uff1a\u4e3b\u8981\u5b9e\u73b0\u5bf9SPI\u786c\u4ef6IP\u7684\u64cd\u4f5c\uff0c\u53e6\u5916\u8fd8\u5b9e\u73b0\u4e86spi framework\u5b9a\u4e49\u7684\u63a5\u53e3\u3002"}),"\n",(0,i.jsx)(n.li,{children:"spi framework\u5c42\uff1a\u53ef\u4ee5\u7406\u89e3\u4e3aspi driver\u7684\u9002\u914d\u5c42\uff0c\u5bf9\u4e0b\u5c42\u5b9a\u4e49\u4e86\u4e00\u7ec4driver\u5c42\u9700\u8981\u5b9e\u73b0\u7684\u63a5\u53e3\uff0c\u5bf9\u4e0a\u63d0\u4f9b\u4e86\u901a\u7528\u63a5\u53e3\u5c4f\u853d\u4e86\u786c\u4ef6\u7ec6\u8282\u3002"}),"\n",(0,i.jsx)(n.li,{children:"spi char device\u5c42\uff1a\u4e3a\u7528\u6237\u7a7a\u95f4\u63d0\u4f9b\u8282\u70b9\uff0c\u65b9\u4fbf\u7528\u6237\u7a7a\u95f4\u4e0e\u5185\u6838\u7a7a\u95f4\u8fdb\u884c\u6570\u636e\u4ea4\u6362\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"\u4ee3\u7801\u8def\u5f84",children:"\u4ee3\u7801\u8def\u5f84"}),"\n",(0,i.jsx)(n.p,{children:"X5\u4f7f\u7528\u65b0\u601d\u7684ssi\u63a7\u5236\u5668\uff0c\u9a71\u52a8\u4ee3\u7801\u4f4d\u4e8e\uff1adrivers/spi\u76ee\u5f55\u4e0b\uff0c\u4e3b\u8981\u6709\u4e09\u4e2a\u6587\u4ef6\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"drivers/spi/spi-dw-core.c\ndrivers/spi/spi-dw-mmio.c\ndrivers/spi/spi-dw-dma.c\n"})}),"\n",(0,i.jsx)(n.h3,{id:"\u63a7\u5236\u5668\u786c\u4ef6\u8bf4\u660e",children:"\u63a7\u5236\u5668\u786c\u4ef6\u8bf4\u660e"}),"\n",(0,i.jsx)(n.p,{children:"X5\u7684\u6240\u6709SPI\u5747\u63a7\u5236\u5668\u53ef\u4ee5\u8fd0\u884cMaster/Slave\u6a21\u5f0f\u3002Master\u53caSlave\u7684\u8fd0\u884c\u9650\u5236\u5982\u4e0b\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SPI-Master\uff1a\u6700\u9ad8\u9891\u738750MHz"}),"\n",(0,i.jsx)(n.li,{children:"SPI-Slave\uff1a\u6700\u9ad8\u9891\u738732MHz"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"X5\u7684\u6240\u6709SPI\u63a7\u5236\u5668\u5747\u53ef\u4ee5\u8fd0\u884c\u5728\u4e2d\u65ad/DMA\u6a21\u5f0f\u3002\u4e2d\u65ad\u6a21\u5f0f\u8fd0\u884c\u9650\u5236\u5982\u4e0b\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["SPI-Slave\uff1a","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Rx\uff1aCPU\u5b9a\u9891\u57281.5GHz\u65f6\uff0c\u53ef\u4ee5\u8fbe\u523032MHz"}),"\n",(0,i.jsx)(n.li,{children:"Tx\uff1aCPU\u5b9a\u9891\u57281.5GHz\u65f6\uff0c\u53ef\u4ee5\u8fbe\u523016MHz"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"SPI-Master\uff1a\u5747\u53ef\u6b63\u5e38\u901a\u8baf\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"dts\u914d\u7f6e\u8bf4\u660e",children:"DTS\u914d\u7f6e\u8bf4\u660e"}),"\n",(0,i.jsxs)(n.p,{children:["X5 SPI\u63a7\u5236\u5668\u7684\u8bbe\u5907\u6811\u5b9a\u4e49\u4f4d\u4e8eSDK\u5305\u7684kernel\u6587\u4ef6\u5939\u4e0b\u7684",(0,i.jsx)(n.code,{children:"arch/arm64/boot/dts/hobot/x5.dtsi"}),"\u6587\u4ef6\u5185\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("font",{color:"red",children:"\u6ce8\u610f\uff1a"}),"x5.dtsi\u4e2d\u7684\u8282\u70b9\u4e3b\u8981\u58f0\u660eSoC\u5171\u6709\u7279\u6027\uff0c\u548c\u5177\u4f53\u7535\u8def\u677f\u65e0\u5173\uff0c\u4e00\u822c\u60c5\u51b5\u4e0b\u4e0d\u7528\u4fee\u6539\u3002"]}),"\n",(0,i.jsx)(n.p,{children:"X5 SPI\u63a7\u5236\u5668\u9ed8\u8ba4\u5173\u95ed\uff0c\u8bf7\u6839\u636e\u5b9e\u9645\u786c\u4ef6\u60c5\u51b5\uff0c\u5728\u5bf9\u5e94\u7684DTS\u6587\u4ef6\u5185\u4f7f\u80fd\u76f8\u5e94\u7684SPI\u63a7\u5236\u5668\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u4ee5\u4f7f\u80fdSPI2\u4e3a\u4f8b\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'&spi2 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_spi2>;\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"dts\u914d\u7f6espi\u4f7f\u7528dma",children:"DTS\u914d\u7f6eSPI\u4f7f\u7528DMA"}),"\n",(0,i.jsx)(n.p,{children:"\u5982\u679c\u9700\u8981\u4f7f\u7528DMA\uff0c\u5219\u9700\u8981\u5728\u5bf9\u5e94\u7684DTS\u6587\u4ef6\u5185\u7ed1\u5b9a\u5bf9\u5e94\u7684DMA\u63e1\u624b\uff0c\u4ee5SPI2\u4e3a\u4f8b\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'&spi2 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_spi2>;\n\tdma-names = "tx", "rx";\n\tdmas = <&axi_dmac 25>, <&axi_dmac 24>;\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"SPI6\u7ed1\u5b9a\u65f6\u9700\u8981\u6307\u5b9adsp_axi_dma\uff0c\u5982\u4e0b\u6240\u793a\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'&spi6 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_dsp_spi>;\n\tdma-names = "tx", "rx";\n\tdmas = <&dsp_axi_dma 21>, <&dsp_axi_dma 20>;\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"SPI DMA\u63e1\u624b\u5217\u8868\u5982\u4e0b\uff1a"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"SPI"}),(0,i.jsx)(n.th,{children:"DMA TX"}),(0,i.jsx)(n.th,{children:"DMA RX"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SPI0"}),(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"21"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SPI1"}),(0,i.jsx)(n.td,{children:"22"}),(0,i.jsx)(n.td,{children:"23"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SPI2"}),(0,i.jsx)(n.td,{children:"24"}),(0,i.jsx)(n.td,{children:"25"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SPI3"}),(0,i.jsx)(n.td,{children:"26"}),(0,i.jsx)(n.td,{children:"27"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SPI4"}),(0,i.jsx)(n.td,{children:"28"}),(0,i.jsx)(n.td,{children:"29"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SPI5"}),(0,i.jsx)(n.td,{children:"30"}),(0,i.jsx)(n.td,{children:"31"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SPI6"}),(0,i.jsx)(n.td,{children:"21"}),(0,i.jsx)(n.td,{children:"22"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"spi\u529f\u80fd\u9a8c\u8bc1",children:"SPI\u529f\u80fd\u9a8c\u8bc1"}),"\n",(0,i.jsx)(n.p,{children:"\u672c\u5c0f\u8282\u4e3b\u8981\u4ecb\u7ecdX5 SPI\u7684\u529f\u80fd\u9a8c\u8bc1\uff0c\u4e3b\u8981\u5305\u62ec\u73af\u5883\u914d\u7f6e\uff0c\u6d4b\u8bd5\u547d\u4ee4\u6267\u884c\u53ca\u6d4b\u8bd5\u4ee3\u7801\u7b49\u3002"}),"\n",(0,i.jsx)(n.h3,{id:"\u6d4b\u8bd5\u73af\u5883\u51c6\u5907",children:"\u6d4b\u8bd5\u73af\u5883\u51c6\u5907"}),"\n",(0,i.jsx)(n.p,{children:"\u786e\u8ba4\u5185\u6838\u7684CONFIG_SPI_SPIDEV\u4e3a\u4f7f\u80fd\u72b6\u6001:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"/* arch/arm64/configs/hobot_x5_soc_defconfig */\n...\nCONFIG_SPI_SPIDEV=m\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u786e\u8ba4\u5728\u5f53\u524d\u786c\u4ef6\u7684DTS\u5185\u9700\u8981\u6d4b\u8bd5\u7684SPI\u63a7\u5236\u5668\u8282\u70b9\u4e0b\u521b\u5efa\u4e86\u4e00\u4e2adummy\u4ece\u8bbe\u5907\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'&spi2 {\n\tspidev@2 {\n\t\tcompatible = "dr,x5-spidev";\n\t\tspi-max-frequency = <32000000>;\n\t\treg = <0>;\n\t};\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"spi-\u5185\u90e8\u56de\u73af\u6d4b\u8bd5",children:"SPI \u5185\u90e8\u56de\u73af\u6d4b\u8bd5"}),"\n",(0,i.jsx)(n.p,{children:"SPI\u5185\u90e8\u56de\u73af\u6d4b\u8bd5\u4ec5SPI Master\u652f\u6301\uff0c\u5176\u539f\u7406\u662fSPI\u786c\u4ef6IP\u7684tx fifo\u5c06\u6570\u636e\u53d1\u7ed9rx fifo\u4ece\u800c\u5f62\u6210\u56de\u73af\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u6d4b\u8bd5\u547d\u4ee4\u53ca\u7ed3\u679c\u53c2\u8003\u5982\u4e0b\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"# modprobe spidev\n# ./spidev_tc -D /dev/spidev2.0 -v -s 1000000 -m 3 -l -e 10 -t 1\n   spi mode: 0x20\n   bits per word: 8\n   max speed: 1000000 Hz (1000 KHz)\n   userspace spi read and write test, len=10 times=1\n   test, times=0\n   TX | 67 C6 69 73 51 FF 4A EC 29 CD __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n\n   RX | 67 C6 69 73 51 FF 4A EC 29 CD __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n"})}),"\n",(0,i.jsx)(n.p,{children:"SPI \u5916\u90e8\u56de\u73af\u6d4b\u8bd5"}),"\n",(0,i.jsx)(n.p,{children:"SPI \u5916\u90e8\u56de\u73af\u6d4b\u8bd5\u662f\u6307\u5b9a\u4e00\u4e2aSPI Slave\uff0c\u4e00\u4e2aSPI Master\uff0c\u5bf9\u5e94\u7ebf\u8fde\u63a5\u8fdb\u884c\u7684\u6d4b\u8bd5\u3002 \u4ee5SPI2\u4f5c\u4e3aSlave\uff0cSPI4\u4f5c\u4e3aMaster\u4e3a\u4f8b\uff1a \u4fee\u6539SPI2 DTS\u4ee5\u652f\u6301Slave\u529f\u80fd\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'&spi2 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_spi2>;\n\tspi-slave;\n\n\tslave@0 {\n\t\tcompatible = "dr,x5-spidev";\n\t\tspi-max-frequency = <32000000>;\n\t\treg = <0>;\n\t};\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"\u4fee\u6539SPI4 DTS\u4ee5\u652f\u6301Master\u529f\u80fd\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'&spi4 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_spi4>;\n\n\tspidev@0 {\n\t\tcompatible = "dr,x5-spidev";\n\t\tspi-max-frequency = <32000000>;\n\t\treg = <0>;\n\t};\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"\u6d4b\u8bd5\u547d\u4ee4\u53ca\u7ed3\u679c\u53c2\u8003\u5982\u4e0b(\u4ee5SPI2\u4e3aSlave\uff0cSPI4\u4e3aMaster)\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"# ./spidev_tc -D /dev/spidev2.0 -v -s 1000000 -m 2 -e 10 -t 1&\n\tbits per word: 8\n\tmax speed: 1000000 Hz (1000 KHz)\n\tuserspace spi write test, len=10 times=1\n\ttest, times=0\n\tTX | 67 C6 69 73 51 FF 4A EC 29 CD __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n\n# ./spidev_tc -D /dev/spidev4.0 -v -s 1000000 -m 1 -e 10 -t 1&\n\tspi mode: 0x0\n\tbits per word: 8\n\tmax speed: 1000000 Hz (1000 KHz)\n\tuserspace spi read test, len=10 times=1\n\ttest, times=0\n\tRX | 67 C6 69 73 51 FF 4A EC 29 CD __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n\n[2]+  Done                       ./spidev_tc -D /dev/spidev2.0 -v -s 1000000 -m 1 -e 10 -t 1\n[1]+  Done                       ./spidev_tc -D /dev/spidev4.0 -v -s 1000000 -m 2 -e 10 -t 1\n"})}),"\n",(0,i.jsx)(n.admonition,{title:"\u5907\u6ce8",type:"info",children:(0,i.jsx)(n.p,{children:"\u5728\u8fdb\u884c\u5916\u90e8\u56de\u73af\u6d4b\u8bd5\u65f6\uff0c\u9700\u8981\u5148\u6267\u884cSPI Slave\u7a0b\u5e8f\uff0c\u518d\u6267\u884cSPI Master\u7a0b\u5e8f\u3002\u5047\u5982\u5148\u6267\u884cSPI Master\u7a0b\u5e8f\uff0c\u540e\u6267\u884cSPI Slave\u7a0b\u5e8f\uff0c\u53ef\u80fd\u4f1a\u7531\u4e8eMaster\u4e0eSlave\u4e0d\u540c\u6b65\u5bfc\u81f4SPI\u63a5\u6536\u6570\u636e\u51fa\u73b0\u4e22\u5931\u3002\u540c\u7406\uff0cspidev_tc\u7684-t\u53c2\u6570\u6700\u597d\u53ea\u6307\u5b9a\u4e00\u6b21\uff0c\u5982\u679c\u60f3\u8fdb\u884c\u591a\u6b21\u6d4b\u8bd5\uff0c\u53ef\u4ee5\u5199\u811a\u672c\u591a\u6b21\u6267\u884c\u6d4b\u8bd5\u7a0b\u5e8f\uff0c\u6765\u4fdd\u8bc1Master\u4e0eSlave\u4e4b\u95f4\u7684\u540c\u6b65\u3002"})}),"\n",(0,i.jsx)(n.h2,{id:"\u9644\u5f55",children:"\u9644\u5f55"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\u9644\u5f551 \u6d4b\u8bd5\u7528\u4f8b\u6e90\u7801\uff1aspidev_tc.c"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'/*\n * SPI testing utility (using spidev driver)\n *\n * Copyright (c) 2007  MontaVista Software, Inc.\n * Copyright (c) 2007  Anton Vorontsov <avorontsov@ru.mvista.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License.\n *\n * Cross-compile with cross-gcc -I/path/to/cross-kernel/include\n */\n\n#include <stdint.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <time.h>\n#include <sys/ioctl.h>\n#include <linux/ioctl.h>\n#include <sys/stat.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\nstatic void pabort(const char *s)\n{\n\tperror(s);\n\tabort();\n}\n\nstatic const char *device = "/dev/spidev1.1";\nstatic uint32_t mode;\nstatic uint8_t bits = 8;\nstatic char *input_file;\nstatic char *output_file;\nstatic uint32_t speed = 500000;\nstatic uint16_t delay;\nstatic int verbose;\nstatic int transfer_size;\nstatic int iterations;\nstatic int interval = 5; /* interval in seconds for showing transfer rate */\nstatic int rw_mode = 0;\t//1: read, 2: write, 3: write and read\nstatic int rw_len = 4;\nstatic int rw_times = 5;\nstatic int frameid_flag = 0;\nstatic int crc_flag = 0;\nstatic int heart_flag = 0;\nstatic uint32_t tx_frameid = 0, rx_frameid = 0;\nstatic uint32_t heart_interval = 5;\t// 5s\n\nuint8_t default_tx[] = {\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0x40, 0x00, 0x00, 0x00, 0x00, 0x95,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xF0, 0x0D,\n};\n\nuint8_t heart_pack[] = {\n\t0xAA, 0x55, 0xAA, 0x55,\n\t0xAA, 0x55, 0xAA, 0x55,\n\t0xAA, 0x55, 0xAA, 0x55,\n\t0xAA, 0x55, 0xAA, 0x55,\n};\n\nuint8_t default_rx[ARRAY_SIZE(default_tx)] = {0, };\nchar *input_tx;\n\n/** CRC table for the CRC-16. The poly is 0x8005 (x^16 + x^15 + x^2 + 1) */\nstatic uint16_t const crc16_table[256] = {\n\t0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,\n\t0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,\n\t0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,\n\t0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,\n\t0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,\n\t0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,\n\t0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,\n\t0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,\n\t0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,\n\t0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,\n\t0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,\n\t0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,\n\t0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,\n\t0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,\n\t0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,\n\t0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,\n\t0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,\n\t0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,\n\t0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,\n\t0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,\n\t0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,\n\t0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,\n\t0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,\n\t0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,\n\t0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,\n\t0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,\n\t0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,\n\t0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,\n\t0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,\n\t0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,\n\t0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,\n\t0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040\n};\n\nstatic inline uint16_t crc16_byte(uint16_t crc, const uint8_t data)\n{\n\treturn (crc >> 8) ^ crc16_table[(crc ^ data) & 0xff];\n}\n\nstatic uint16_t crc16(uint16_t crc, uint8_t const *buffer, size_t len)\n{\n\twhile (len--)\n\t\tcrc = crc16_byte(crc, *buffer++);\n\treturn crc;\n}\n\nstatic void hex_dump(const void *src, size_t length, size_t line_size,\n\t\t     char *prefix)\n{\n\tint i = 0;\n\tconst unsigned char *address = src;\n\tconst unsigned char *line = address;\n\tunsigned char c;\n\n\tprintf("%s | ", prefix);\n\twhile (length-- > 0) {\n\t\tprintf("%02X ", *address++);\n\t\tif (!(++i % line_size) || (length == 0 && i % line_size)) {\n\t\t\tif (length == 0) {\n\t\t\t\twhile (i++ % line_size)\n\t\t\t\t\tprintf("__ ");\n\t\t\t}\n\t\t\tprintf(" | ");  /* right close */\n\t\t\twhile (line < address) {\n\t\t\t\tc = *line++;\n\t\t\t\tprintf("%c", (c < 33 || c == 255) ? 0x2E : c);\n\t\t\t}\n\t\t\tprintf("\\n");\n\t\t\tif (length > 0)\n\t\t\t\tprintf("%s | ", prefix);\n\t\t}\n\t}\n}\n\nstatic void hex_dump2(const void *src, size_t length, size_t line_size,\n\t\t  char *prefix)\n{\n     int i = 0;\n     const unsigned char *address = src;\n\n     printf("%s | ", prefix);\n     while (length-- > 0) {\n\t     printf("%02X ", *address++);\n\t     if (!(++i % line_size) || (length == 0 && i % line_size)) {\n\t\t     if (length == 0) {\n\t\t\t     while (i++ % line_size)\n\t\t\t\t     printf("__ ");\n\t\t     }\n\t\t     printf("\\n");\n\t\t     if (length > 0)\n\t\t\t     printf("%s | ", prefix);\n\t     }\n     }\n     printf("\\n");\n}\n\n/*\n *  Unescape - process hexadecimal escape character\n *      converts shell input "\\x23" -> 0x23\n */\nstatic int unescape(char *_dst, char *_src, size_t len)\n{\n\tint ret = 0;\n\tint match;\n\tchar *src = _src;\n\tchar *dst = _dst;\n\tunsigned int ch;\n\n\twhile (*src) {\n\t\tif (*src == \'\\\\\' && *(src+1) == \'x\') {\n\t\t\tmatch = sscanf(src + 2, "%2x", &ch);\n\t\t\tif (!match)\n\t\t\t\tpabort("malformed input string");\n\n\t\t\tsrc += 4;\n\t\t\t*dst++ = (unsigned char)ch;\n\t\t} else {\n\t\t\t*dst++ = *src++;\n\t\t}\n\t\tret++;\n\t}\n\treturn ret;\n}\n\nstatic void transfer(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n\tint ret;\n\tint out_fd;\n\tstruct spi_ioc_transfer tr = {\n\t\t.tx_buf = (unsigned long)tx,\n\t\t.rx_buf = (unsigned long)rx,\n\t\t.len = len,\n\t\t.delay_usecs = delay,\n\t\t.speed_hz = speed,\n\t\t.bits_per_word = bits,\n\t};\n\n\tstruct timespec currentTime;\n\tstruct timespec currentTime1;\n\n\tif (mode & SPI_TX_QUAD)\n\t\ttr.tx_nbits = 4;\n\telse if (mode & SPI_TX_DUAL)\n\t\ttr.tx_nbits = 2;\n\tif (mode & SPI_RX_QUAD)\n\t\ttr.rx_nbits = 4;\n\telse if (mode & SPI_RX_DUAL)\n\t\ttr.rx_nbits = 2;\n\tif (!(mode & SPI_LOOP)) {\n\t\tif (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n\t\t\ttr.rx_buf = 0;\n\t\telse if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n\t\t\ttr.tx_buf = 0;\n\t}\n\n\tclock_gettime(CLOCK_REALTIME, &currentTime);\n\tlong milliseconds = currentTime.tv_nsec / 1000000;\n\tprintf("before trans time: %ld ms\\n", milliseconds);\n\tret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n\tif (ret < 1)\n\t\tpabort("can\'t send spi message");\n\tclock_gettime(CLOCK_REALTIME, &currentTime1);\n\tlong milliseconds1 = currentTime1.tv_nsec / 1000000;\n\tprintf("after trans time: %ld ms\\n", milliseconds1);\n\n\tprintf("diff: %ld ms\\n", (milliseconds1 - milliseconds));\n\n\tif (verbose)\n\t\thex_dump(tx, len, 32, "TX");\n\n\tif (output_file) {\n\t\tout_fd = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\t\tif (out_fd < 0)\n\t\t\tpabort("could not open output file");\n\n\t\tret = write(out_fd, rx, len);\n\t\tif (ret != len)\n\t\t\tpabort("not all bytes written to output file");\n\n\t\tclose(out_fd);\n\t}\n\n\tif (verbose)\n\t\thex_dump(rx, len, 32, "RX");\n}\n\nstatic void transfer2(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n\tint ret;\n\tint out_fd;\n\tstruct spi_ioc_transfer tr = {\n\t\t.tx_buf = (unsigned long)tx,\n\t\t.rx_buf = (unsigned long)rx,\n\t\t.len = len,\n\t\t.delay_usecs = delay,\n\t\t.speed_hz = speed,\n\t\t.bits_per_word = bits,\n\t};\n\n\tif (mode & SPI_TX_QUAD)\n\t\ttr.tx_nbits = 4;\n\telse if (mode & SPI_TX_DUAL)\n\t\ttr.tx_nbits = 2;\n\tif (mode & SPI_RX_QUAD)\n\t\ttr.rx_nbits = 4;\n\telse if (mode & SPI_RX_DUAL)\n\t\ttr.rx_nbits = 2;\n\tif (!(mode & SPI_LOOP)) {\n\t\tif (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n\t\t\ttr.rx_buf = 0;\n\t\telse if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n\t\t\ttr.tx_buf = 0;\n\t}\n\n\tif (verbose && rw_mode >> 1)\n\t\thex_dump2(tx, len, 32, "TX");\n\n\tret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n\tif (ret < 1) {\n\t\t//pabort("can\'t send spi message");\n\t\tprintf("can\'t send spi message");\n\t} else {\n\t\tif (output_file) {\n\t\t\tout_fd = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\t\t\tif (out_fd < 0)\n\t\t\t\tpabort("could not open output file");\n\n\t\t\tret = write(out_fd, rx, len);\n\t\t\tif (ret != len)\n\t\t\t\tpabort("not all bytes written to output file");\n\n\t\t\tclose(out_fd);\n\t\t}\n\n\t\tif (verbose && rw_mode&0x01)\n\t\t\thex_dump2(rx, len, 32, "RX");\n\t}\n\tif (strcmp(tx, rx) != 0) {\n\t\tprintf("SPI transfer failed\\n");\n\t\texit(-1);\n\t}\n\n}\n\nstatic void transfer3(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n\tint ret;\n\tuint8_t const *p = rx;\n\tstruct spi_ioc_transfer tr = {\n\t\t.tx_buf = (unsigned long)tx,\n\t\t.rx_buf = (unsigned long)rx,\n\t\t.len = len,\n\t\t.delay_usecs = delay,\n\t\t.speed_hz = speed,\n\t\t.bits_per_word = bits,\n\t};\n\n\tif (mode & SPI_TX_QUAD)\n\t\ttr.tx_nbits = 4;\n\telse if (mode & SPI_TX_DUAL)\n\t\ttr.tx_nbits = 2;\n\tif (mode & SPI_RX_QUAD)\n\t\ttr.rx_nbits = 4;\n\telse if (mode & SPI_RX_DUAL)\n\t\ttr.rx_nbits = 2;\n\tif (!(mode & SPI_LOOP)) {\n\t\tif (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n\t\t\ttr.rx_buf = 0;\n\t\telse if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n\t\t\ttr.tx_buf = 0;\n\t}\n\n\thex_dump2(tx, len, 32, "TX");\n\n\tret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n\tif (ret < 1) {\n\t\tprintf("can\'t send spi message");\n\t} else {\n\t\thex_dump2(rx, len, 32, "RX");\n\n\t\tif (frameid_flag) {\n\t\t\tuint32_t *pframeid = (uint32_t *)p;\n\t\t\trx_frameid = *pframeid;\n\t\t\tp += sizeof(uint32_t);\n\n\t\t\tprintf("device = %s, crc_val = %d", device, rx_frameid);\n\t\t}\n\n\t\tif (crc_flag) {\n\t\t\tuint16_t crc_val_check = crc16(0, p, sizeof(heart_pack));\n\t\t\tp += sizeof(heart_pack);\n\t\t\tuint16_t *pcrc_val = (uint16_t *)p;\n\n\t\t\tprintf("device = %s, crc_val = %d, crc_val_check = %d", device, *pcrc_val, crc_val_check);\n\t\t}\n\t}\n}\n\nstatic void print_usage(const char *prog)\n{\n\tprintf("Usage: %s [-DsbdiolHOLC3vpNR24SImetfch1]\\n", prog);\n\tputs("  -D --device   device to use (default /dev/spidev1.1)\\n"\n\t     "  -s --speed    max speed (Hz)\\n"\n\t     "  -d --delay    delay (usec)\\n"\n\t     "  -b --bpw      bits per word\\n"\n\t     "  -i --input    input data from a file (e.g. \\"test.bin\\")\\n"\n\t     "  -o --output   output data to a file (e.g. \\"results.bin\\")\\n"\n\t     "  -l --loop     loopback\\n"\n\t     "  -H --cpha     clock phase\\n"\n\t     "  -O --cpol     clock polarity\\n"\n\t     "  -L --lsb      least significant bit first\\n"\n\t     "  -C --cs-high  chip select active high\\n"\n\t     "  -3 --3wire    SI/SO signals shared\\n"\n\t     "  -v --verbose  Verbose (show tx buffer)\\n"\n\t     "  -p            Send data (e.g. \\"1234\\\\xde\\\\xad\\")\\n"\n\t     "  -N --no-cs    no chip select\\n"\n\t     "  -R --ready    slave pulls low to pause\\n"\n\t     "  -2 --dual     dual transfer\\n"\n\t     "  -4 --quad     quad transfer\\n"\n\t     "  -S --size     transfer size\\n"\n\t     "  -I --iter     iterations\\n"\n\t     "  -m --rw-mode  1 read, 2 write, 3 write and read\\n"\n\t     "  -e --rw-len   read or write len\\n"\n\t     "  -t --rw-times read or write times\\n"\n\t\t "  -f --frame-id support frame id\\n"\n\t\t "  -c --crc support crc\\n"\n\t\t "  -h --heart pack for test\\n"\n\t\t "  -1 --heart pack interval(default: 5s)\\n");\n\texit(1);\n}\n\nstatic void parse_opts(int argc, char *argv[])\n{\n\twhile (1) {\n\t\tstatic const struct option lopts[] = {\n\t\t\t{ "device",  1, 0, \'D\' },\n\t\t\t{ "speed",   1, 0, \'s\' },\n\t\t\t{ "delay",   1, 0, \'d\' },\n\t\t\t{ "bpw",     1, 0, \'b\' },\n\t\t\t{ "input",   1, 0, \'i\' },\n\t\t\t{ "output",  1, 0, \'o\' },\n\t\t\t{ "loop",    0, 0, \'l\' },\n\t\t\t{ "cpha",    0, 0, \'H\' },\n\t\t\t{ "cpol",    0, 0, \'O\' },\n\t\t\t{ "lsb",     0, 0, \'L\' },\n\t\t\t{ "cs-high", 0, 0, \'C\' },\n\t\t\t{ "3wire",   0, 0, \'3\' },\n\t\t\t{ "no-cs",   0, 0, \'N\' },\n\t\t\t{ "ready",   0, 0, \'R\' },\n\t\t\t{ "dual",    0, 0, \'2\' },\n\t\t\t{ "verbose", 0, 0, \'v\' },\n\t\t\t{ "quad",    0, 0, \'4\' },\n\t\t\t{ "size",    1, 0, \'S\' },\n\t\t\t{ "iter",    1, 0, \'I\' },\n\t\t\t{ "rw-mode",    1, 0, \'m\' },\n\t\t\t{ "rw-len",    1, 0, \'e\' },\n\t\t\t{ "rw-times",    1, 0, \'t\' },\n\t\t\t{ "frame-id",\t0, 0, \'f\' },\n\t\t\t{ "crc", 0, 0, \'c\' },\n\t\t\t{ "heart", 0, 0, \'h\' },\n\t\t\t{ "interval", 0, 0, \'1\' },\n\t\t\t{ NULL, 0, 0, 0 },\n\t\t};\n\t\tint c;\n\n\t\tc = getopt_long(argc, argv, "D:s:d:b:i:o:lHOLC3NR24p:vS:I:m:e:t:fch1:",\n\t\t\t\tlopts, NULL);\n\t\t//printf("optind: %d\\n", optind);\n\t\t//printf("optarg: %s\\n", optarg);\n\t\t//printf("option: %c\\n", c);\n\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase \'D\':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\t\tcase \'s\':\n\t\t\tspeed = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'d\':\n\t\t\tdelay = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'b\':\n\t\t\tbits = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'i\':\n\t\t\tinput_file = optarg;\n\t\t\tbreak;\n\t\tcase \'o\':\n\t\t\toutput_file = optarg;\n\t\t\tbreak;\n\t\tcase \'l\':\n\t\t\tmode |= SPI_LOOP;\n\t\t\tbreak;\n\t\tcase \'H\':\n\t\t\tmode |= SPI_CPHA;\n\t\t\tbreak;\n\t\tcase \'O\':\n\t\t\tmode |= SPI_CPOL;\n\t\t\tbreak;\n\t\tcase \'L\':\n\t\t\tmode |= SPI_LSB_FIRST;\n\t\t\tbreak;\n\t\tcase \'C\':\n\t\t\tmode |= SPI_CS_HIGH;\n\t\t\tbreak;\n\t\tcase \'3\':\n\t\t\tmode |= SPI_3WIRE;\n\t\t\tbreak;\n\t\tcase \'N\':\n\t\t\tmode |= SPI_NO_CS;\n\t\t\tbreak;\n\t\tcase \'v\':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase \'R\':\n\t\t\tmode |= SPI_READY;\n\t\t\tbreak;\n\t\tcase \'p\':\n\t\t\tinput_tx = optarg;\n\t\t\tbreak;\n\t\tcase \'2\':\n\t\t\tmode |= SPI_TX_DUAL;\n\t\t\tbreak;\n\t\tcase \'4\':\n\t\t\tmode |= SPI_TX_QUAD;\n\t\t\tbreak;\n\t\tcase \'S\':\n\t\t\ttransfer_size = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'I\':\n\t\t\titerations = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'m\':\n\t\t\trw_mode = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'e\':\n\t\t\trw_len = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'t\':\n\t\t\trw_times = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'f\':\n\t\t\tframeid_flag = 1;\n\t\t\tbreak;\n\t\tcase \'c\':\n\t\t\tcrc_flag = 1;\n\t\t\tbreak;\n\t\tcase \'h\':\n\t\t\theart_flag = 1;\n\t\t\tbreak;\n\t\tcase \'1\':\n\t\t\theart_interval = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode & SPI_LOOP) {\n\t\tif (mode & SPI_TX_DUAL)\n\t\t\tmode |= SPI_RX_DUAL;\n\t\tif (mode & SPI_TX_QUAD)\n\t\t\tmode |= SPI_RX_QUAD;\n\t}\n}\n\nstatic void transfer_escaped_string(int fd, char *str)\n{\n\tsize_t size = strlen(str);\n\tuint8_t *tx;\n\tuint8_t *rx;\n\n\ttx = malloc(size);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\n\trx = malloc(size);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\tsize = unescape((char *)tx, str, size);\n\ttransfer(fd, tx, rx, size);\n\tfree(rx);\n\tfree(tx);\n}\n\nstatic void transfer_file(int fd, char *filename)\n{\n\tssize_t bytes;\n\tstruct stat sb;\n\tint tx_fd;\n\tuint8_t *tx;\n\tuint8_t *rx;\n\n\tif (stat(filename, &sb) == -1)\n\t\tpabort("can\'t stat input file");\n\n\ttx_fd = open(filename, O_RDONLY);\n\tif (tx_fd < 0)\n\t\tpabort("can\'t open input file");\n\n\ttx = malloc(sb.st_size);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\n\trx = malloc(sb.st_size);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\tbytes = read(tx_fd, tx, sb.st_size);\n\tif (bytes != sb.st_size)\n\t\tpabort("failed to read input file");\n\n\ttransfer(fd, tx, rx, sb.st_size);\n\tfree(rx);\n\tfree(tx);\n\tclose(tx_fd);\n}\n\nstatic uint64_t _read_count;\nstatic uint64_t _write_count;\n\nstatic void show_transfer_rate(void)\n{\n\tstatic uint64_t prev_read_count, prev_write_count;\n\tdouble rx_rate, tx_rate;\n\n\trx_rate = ((_read_count - prev_read_count) * 8) / (interval*1000.0);\n\ttx_rate = ((_write_count - prev_write_count) * 8) / (interval*1000.0);\n\n\tprintf("rate: tx %.1fkbps, rx %.1fkbps\\n", rx_rate, tx_rate);\n\n\tprev_read_count = _read_count;\n\tprev_write_count = _write_count;\n}\n\nstatic void transfer_buf(int fd, int len)\n{\n\tuint8_t *tx;\n\tuint8_t *rx;\n\tint i;\n\n\ttx = malloc(len);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\tfor (i = 0; i < len; i++)\n\t\ttx[i] = random();\n\n\trx = malloc(len);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\ttransfer(fd, tx, rx, len);\n\n\t_write_count += len;\n\t_read_count += len;\n\n\tif (mode & SPI_LOOP) {\n\t\tif (memcmp(tx, rx, len)) {\n\t\t\tfprintf(stderr, "transfer error !\\n");\n\t\t\thex_dump(tx, len, 32, "TX");\n\t\t\thex_dump(rx, len, 32, "RX");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfree(rx);\n\tfree(tx);\n}\n\nstatic void transfer_read_write(int fd)\n{\n\tuint8_t *tx;\n\tuint8_t *rx;\n\tint i, j;\n\tint len, times;\n\tchar str[64] = {0};\n\n\tlen = rw_len > 0 ? rw_len : 4;\n\ttimes = rw_times > 0 ? rw_times : 4;\n\tif (rw_mode == 2)\n\t\tsprintf(str, "write");\n\telse if (rw_mode == 3)\n\t\tsprintf(str, "read and write");\n\telse {\n\t\trw_mode = 1;\n\t\tsprintf(str, "read");\n\t}\n\n\tprintf("userspace spi %s test, len=%d times=%d\\n", str, len, times);\n\n\ttx = malloc(len + 4);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\trx = malloc(len + 4);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\tfor (j = 0; j < rw_times; j++) {\n\t\tmemset(tx, 0, len);\n\t\tmemset(rx, 0, len);\n\n\t\tif (rw_mode >> 1) {\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\ttx[i] = random();\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\ttx[i] = i;\n\t\t}\n\t\tprintf("test, times=%d\\n", j);\n\t\ttransfer2(fd, tx, rx, len);\n\t\t//sleep(2);\n\t}\n}\n\nstatic void transfer_heart_pack(int fd)\n{\n\tuint8_t *p;\n\tuint8_t *tx;\n\tuint8_t *rx;\n\tint len;\n\n\tlen = sizeof(heart_pack);\n\tif (frameid_flag)\n\t\tlen += sizeof(uint32_t);\n\tif (crc_flag)\n\t\tlen += sizeof(uint16_t);\n\n\ttx = malloc(len);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\trx = malloc(len);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\twhile (1) {\n\t\tmemset(tx, 0 ,len);\n\t\tmemset(rx, 0, len);\n\n\t\tp = tx;\n\t\tif (frameid_flag) {\n\t\t\tuint32_t *pframeid = (uint32_t *)p;\n\t\t\t*pframeid = tx_frameid;\n\t\t\ttx_frameid++;\n\t\t\tp += sizeof(uint32_t);\n\n\t\t\tprintf("device = %s, crc_val = %d", device, *pframeid);\n\t\t}\n\n\t\tmemcpy(p, heart_pack, sizeof(heart_pack));\n\t\tp += sizeof(heart_pack);\n\n\t\tif (crc_flag) {\n\t\t\tuint16_t crc_val = crc16(0, heart_pack, sizeof(heart_pack));\n\t\t\tuint16_t *pcrc_val = (uint16_t *)p;\n\t\t\t*pcrc_val = crc_val;\n\n\t\t\tprintf("device = %s, crc_val = %d", device, crc_val);\n\t\t}\n\n\t\ttransfer3(fd, tx, rx, len);\n\n\t\tsleep(heart_interval);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret = 0;\n\tint fd;\n\n\tparse_opts(argc, argv);\n\n\tfd = open(device, O_RDWR);\n\tif (fd < 0)\n\t\tpabort("can\'t open device");\n\n\t/*\n\t * spi mode\n\t */\n\tret = ioctl(fd, SPI_IOC_WR_MODE32, &mode);\n\tif (ret == -1)\n\t\tpabort("can\'t set spi mode");\n\n\tret = ioctl(fd, SPI_IOC_RD_MODE32, &mode);\n\tif (ret == -1)\n\t\tpabort("can\'t get spi mode");\n\n\t/*\n\t * bits per word\n\t */\n\tret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);\n\tif (ret == -1)\n\t\tpabort("can\'t set bits per word");\n\n\tret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits);\n\tif (ret == -1)\n\t\tpabort("can\'t get bits per word");\n\n\t/*\n\t * max speed hz\n\t */\n\tret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);\n\tif (ret == -1)\n\t\tpabort("can\'t set max speed hz");\n\n\tret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed);\n\tif (ret == -1)\n\t\tpabort("can\'t get max speed hz");\n\n\tprintf("spi mode: 0x%x\\n", mode);\n\tprintf("bits per word: %d\\n", bits);\n\tprintf("max speed: %d Hz (%d KHz)\\n", speed, speed/1000);\n\n\tif (input_tx && input_file)\n\t\tpabort("only one of -p and --input may be selected");\n\n\tif (input_tx)\n\t\ttransfer_escaped_string(fd, input_tx);\n\telse if (input_file)\n\t\ttransfer_file(fd, input_file);\n\telse if (transfer_size) {\n\t\tstruct timespec last_stat;\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &last_stat);\n\n\t\twhile (iterations-- > 0) {\n\t\t\tstruct timespec current;\n\n\t\t\ttransfer_buf(fd, transfer_size);\n\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &current);\n\t\t\tif (current.tv_sec - last_stat.tv_sec > interval) {\n\t\t\t\tshow_transfer_rate();\n\t\t\t\tlast_stat = current;\n\t\t\t}\n\t\t}\n\t\tprintf("total: tx %.1fKB, rx %.1fKB\\n",\n\t\t       _write_count/1024.0, _read_count/1024.0);\n\t} else if (rw_mode) {\n\t\ttransfer_read_write(fd);\n\t} else if (heart_flag) {\n\t\ttransfer_heart_pack(fd);\n\t} else\n\t\ttransfer(fd, default_tx, default_rx, sizeof(default_tx));\n\n\tclose(fd);\n\n\treturn ret;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\u9644\u5f552 \u6d4b\u8bd5\u7528\u4f8b\u6e90\u7801\uff1aMakefile"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"OUT_DIR = $(shell pwd)/_build/\n\n.PHONY: build install clean\n\nBIN_NAME = spidev_tc\nSRCS = $(wildcard ./*.c)\nOBJS = $(addprefix ${OUT_DIR}/, $(patsubst %.c, %.o, ${SRCS}))\n\nBIN_TEST1 = ${OUT_DIR}/${BIN_NAME}\nOBJECT = ${BIN_TEST1}\n\nbuild: ${OBJECT}\n\nQ:=\n\n$(OBJECT): $(OBJS)\n\t$(Q)mkdir -p $(abspath $(dir $@))\n\t$(Q)echo CC $@\n\t$(Q)${CC} ${CFLAGS} ${INCS} $^ ${LDFLAGS} $(LIBS) -o $@\n\n${OUT_DIR}/%.o: %.c\n\t$(Q)mkdir -p $(abspath $(dir $@))\n\t$(Q)echo CC $@\n\t$(Q)${CC} $(INCS) -c $< -o $@\n\nclean :\n\trm -rf $(OBJS) $(OBJECT)\n"})})]})}function l(t={}){const{wrapper:n}={...(0,r.R)(),...t.components};return n?(0,i.jsx)(n,{...t,children:(0,i.jsx)(x,{...t})}):x(t)}},28453:(t,n,e)=>{e.d(n,{R:()=>a,x:()=>d});var i=e(96540);const r={},s=i.createContext(r);function a(t){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function d(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:a(t.components),i.createElement(s.Provider,{value:n},t.children)}}}]);